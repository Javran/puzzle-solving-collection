{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE TupleSections #-}

module Game.Tents.Parser where

import Control.Monad
import Data.Char
import qualified Data.Map.Strict as M
import Data.Maybe
import qualified Data.Vector as V
import Game.Tents.Types
import Paths_tents_solver
import Text.ParserCombinators.ReadP

loadPuzzles :: IO [(String, BoardRep)]
loadPuzzles = do
  fName <- getDataFileName "data/puzzles.txt"
  raw <- readFile fName
  let bds = parseBatchBoards raw
  pure bds

{-
  syntax draft:
  - first line: <rows> <cols>
  - next <rows> lines: board presentation <space> <number>
    + board:
      - '?': unknown
      - '_': empty
      - 'R': tree (tRee)
      - 'E': tent (tEnt)
  - last line: numbers, space-separated.
 -}
rawPuzzle0 :: String
rawPuzzle0 =
  unlines
    [ "9 8"
    , "??R????_ 1"
    , "???R?R?? 2"
    , "R??????? 1"
    , "???????? 1"
    , "?R??R?RR 2"
    , "??R???R? 2"
    , "?R?????R 2"
    , "?????R?? 2"
    , "ER?????? 1"
    , "3 2 1 1 2 1 2 2"
    ]

rawPuzzle1 :: String
rawPuzzle1 =
  unlines
    [ "21 21"
    , "?R????????R????R????R 5"
    , "???????R?????R??????? 3"
    , "R???R???R??R?R??????? 2"
    , "????????????R?R?????R 6"
    , "????R???R???R????R??R 3"
    , "?RR??RR??R?????RR???R 7"
    , "??????R???R?????????? 1"
    , "?R?R?????????R??????R 5"
    , "?R???RRR????????????? 5"
    , "???????????????R??R?? 2"
    , "??RR??RR???????R????? 5"
    , "?R??????R?RRR????R??? 5"
    , "???????????????R???R? 3"
    , "R??????????????R?R?R? 4"
    , "???RRRR?R???R??R????? 4"
    , "?????????????R???R?R? 6"
    , "R???????????R????R??? 3"
    , "???????R?R???R??????? 4"
    , "R???R?R???R????R???R? 3"
    , "R??R???R??????R??R??? 6"
    , "??????????????????R?? 2"
    , "6 4 4 2 6 1 7 1 7 2 4 5 3 5 3 4 4 3 4 3 6"
    ]

rawPuzzle2 :: String
rawPuzzle2 =
  unlines
    [ "20 20"
    , "R??RRR?R???????R?RR? 6"
    , "???????????R?R??R??? 4"
    , "???????R???????????? 3"
    , "???R??R???R???R??R?? 6"
    , "RR?RR????R??R??????R 0"
    , "??????R?????????R??? 8"
    , "??R?R??????????R???R 1"
    , "?R??????????R????R?? 5"
    , "?????R????R????????? 3"
    , "???????R?????R???R?R 3"
    , "?R?????R???R???????R 6"
    , "R????R??????R?R????? 3"
    , "??????R???R???R??R?? 2"
    , "R?????R???????R????? 4"
    , "???R?????R??R????R?? 5"
    , "?R????????R?????R??? 3"
    , "??R?R????R?R?R?R??R? 5"
    , "R?R?R??????????????? 4"
    , "R???R???RR???R?????? 2"
    , "?R?????R????????RR?? 7"
    , "6 3 6 3 5 3 4 3 6 2 5 2 5 3 4 2 7 2 5 4"
    ]

rawPuzzle3 :: String
rawPuzzle3 =
  unlines
    [ "17 17"
    , "?R?R??????R????R? 5"
    , "???R???R?R?R??R?R 2"
    , "?????R????R?????? 5"
    , "?R????R?????????? 2"
    , "????R????R???RRR? 4"
    , "???R????????R??R? 2"
    , "R???R?R?????????? 5"
    , "?R??????R?R?????? 0"
    , "?????????????R??? 6"
    , "???R????????R???R 2"
    , "???R??RR????????? 3"
    , "??R???R???R?????R 4"
    , "????R???R?R??R??R 2"
    , "??????????????R?? 4"
    , "?RR??R?????R?R??? 2"
    , "??R?????RR??????R 5"
    , "R?????????????R?? 3"
    , "3 4 1 5 3 3 3 4 2 4 3 3 3 4 2 3 6"
    ]

rawPuzzle4 :: String
rawPuzzle4 =
  unlines
    [ "15 15"
    , "???R?R???R?R?R? 4"
    , "??R??????R????? 3"
    , "R????????RR???? 2"
    , "???R????????R?? 3"
    , "R??R?R????R???? 2"
    , "????????????R?? 3"
    , "?R???R?R?????R? 3"
    , "R?????????????? 1"
    , "?R?R?R???R??R?? 6"
    , "?????????R?R?R? 1"
    , "??????R?R?????? 5"
    , "?R?R??R??????R? 1"
    , "???R???R??????? 5"
    , "???????????RR?R 1"
    , "?RR?R???R??R??? 6"
    , "5 1 4 2 3 3 4 2 4 2 3 4 2 4 3"
    ]

int :: ReadP Int
int = read <$> munch1 isDigit

dimsLine :: ReadP (Int, Int)
dimsLine = (,) <$> (int <* char ' ') <*> (int <* char '\n')

cell :: ReadP (Maybe Cell)
cell =
  (Nothing <$ char '?')
    <++ (Just Empty <$ char '_')
    <++ (Just Tree <$ char 'R')
    <++ (Just Tent <$ char 'E')

boardLine :: Int -> ReadP ([Maybe Cell], Int)
boardLine cols =
  (,)
    <$> (replicateM cols cell <* char ' ')
    <*> (int <* char '\n')

lastLine :: Int -> ReadP [Int]
lastLine cols = do
  xs <- int `sepBy` char ' '
  guard $ length xs == cols
  xs <$ char '\n'

boardRep :: ReadP BoardRep
boardRep = do
  brDims@(rows, cols) <- dimsLine
  zippedResults <- replicateM rows (boardLine cols)
  let brRowTentCounts = V.fromListN rows (snd <$> zippedResults)
      joinedLines = concatMap fst zippedResults
      brBoard =
        M.fromList
          . mapMaybe (\(coord, m) -> (coord,) <$> m)
          $ zip [(row, col) | row <- [0 .. rows -1], col <- [0 .. cols -1]] joinedLines
  brColTentCounts <- V.fromListN cols <$> lastLine cols
  pure
    BoardRep
      { brDims
      , brRowTentCounts
      , brColTentCounts
      , brBoard
      }

parseBoard :: String -> Maybe BoardRep
parseBoard raw = case readP_to_S (boardRep <* eof) raw of
  [(v, "")] -> pure v
  _ -> Nothing

puzzleIdLine :: ReadP String
puzzleIdLine =
  string "# " *> munch1 (not . isSpace) <* char '\n'

oneBoardInBatch :: ReadP (String, BoardRep)
oneBoardInBatch = (,) <$> puzzleIdLine <*> boardRep

parseBatchBoards :: String -> [(String, BoardRep)]
parseBatchBoards raw = case readP_to_S (many oneBoardInBatch <* eof) raw of
  [(v, "")] -> v
  _ -> []
